<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>World Map</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      property="og:image"
      content="https://world-map.nathanfriend.io/screenshot.jpg"
    />
    <meta property="og:title" content="World Map" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://world-map.nathanfriend.io" />
    <meta
      property="og:description"
      content="A web page that displays a world map, configured by data passed through the URL"
    />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
    <meta name="msapplication-TileColor" content="#da532c" />
    <meta name="theme-color" content="#333333" />

    <style>
      body {
        margin: 0;
      }

      .label-popover {
        text-align: center;
        max-width: 200px;
        margin-top: 15px;
        padding: 10px;
        border-radius: 5px;
        background-color: rgba(0, 0, 0, 0.7);
      }

      .label-popover .label-header {
        margin-bottom: 5px;
        font-weight: bold;
      }
    </style>

    <script src="./third-party/globe.gl.min.js"></script>
    <script src="./third-party/d3.min.js"></script>
  </head>

  <body>
    <div id="globeViz"></div>

    <script>
      const searchParams = new URLSearchParams(window.location.search);

      fetch('./data/countries.geojson')
        .then((res) => res.json())
        .then((countries) => {
          // Get a mapping of all countries to the value specified
          // in the URL via [country code]_value
          const countryVals = countries.features
            .map((f) => f.properties.ISO_A2.toLowerCase())
            .filter((code) => /^[a-z]{2}$/.test(code))
            .reduce((acc, code) => {
              if (searchParams.has(code + '_value')) {
                acc[code] = parseFloat(searchParams.get(code + '_value'));
              } else {
                acc[code] = searchParams.get('default_value') ?? 0;
              }

              return acc;
            }, {});

          const maxCountryVal = Math.max(...Object.values(countryVals));
          const minCountryVal = Math.min(...Object.values(countryVals));

          const allowedInterpolateFns = Object.keys(d3).filter((fnName) =>
            /^interpolate.*$/.test(fnName),
          );

          const requestedInterpolateFn = searchParams.get('interpolate_fn');
          const interpolateFn =
            requestedInterpolateFn &&
            allowedInterpolateFns.includes(requestedInterpolateFn)
              ? requestedInterpolateFn
              : 'interpolateYlOrRd';

          const colorScale = d3
            .scaleSequentialSqrt(d3[interpolateFn])
            .domain([minCountryVal, maxCountryVal]);

          const world = Globe();

          if (searchParams.get('background') === 'stars') {
            world.backgroundImageUrl('./third-party/night-sky.png');
          } else if (searchParams.has('background')) {
            world.backgroundColor(searchParams.get('background'));
          }

          if (searchParams.get('globe_style') === 'hollow') {
            world
              .showGlobe(false)
              .showAtmosphere(false)
              .polygonSideColor(() => 'rgba(0, 0, 0, 0)');
          } else if (searchParams.get('globe_style') === 'night') {
            world.globeImageUrl('./third-party/earth-night.jpg');
          } else {
            world.globeImageUrl('./third-party/earth-day.jpg');
          }

          const computeCountryColor = (countryCode, darken = false) => {
            const countryColor = searchParams.get(countryCode + '_color');

            const countryValueColor =
              (searchParams.has(countryCode + '_value') ||
                searchParams.has('default_value')) &&
              colorScale(countryVals[countryCode]);

            const defaultColor = searchParams.get('default_color');

            const color =
              countryColor || countryValueColor || defaultColor || 'gray';

            return darken ? d3.color(color).darker() : color;
          };

          const countryAltitude = 0.01;
          const hoverLift = parseFloat(searchParams.get('hover_lift') ?? 0.02);

          world
            .lineHoverPrecision(0)
            .polygonsData(countries.features)
            .polygonAltitude(countryAltitude)
            .polygonCapColor((feat) =>
              computeCountryColor(feat.properties.ISO_A2.toLowerCase()),
            )
            .polygonSideColor((feat) =>
              computeCountryColor(feat.properties.ISO_A2.toLowerCase(), true),
            )
            .polygonStrokeColor(() => '#111')
            .polygonLabel(({ properties }) => {
              const label =
                searchParams.get(properties.ISO_A2.toLowerCase() + '_label') ??
                searchParams.get('default_label');

              if (label) {
                return `<div class="label-popover">
                          <div class="label-header">${properties.ADMIN} (${properties.ISO_A2}):</div>
                          ${label}
                        </div>`;
              } else {
                return null;
              }
            })
            .onPolygonHover((hoverD) =>
              world.polygonAltitude((d) =>
                d === hoverD ? countryAltitude + hoverLift : countryAltitude,
              ),
            )
            .polygonsTransitionDuration(150)(
            document.getElementById('globeViz'),
          );
        });
    </script>
  </body>
</html>
